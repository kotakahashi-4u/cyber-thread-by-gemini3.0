<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CYBER THREAD</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #00f;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            text-align: left;
            pointer-events: none;
            z-index: 10;
        }

        .score-val {
            font-size: 32px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }

        /* Buttons */
        .btn {
            pointer-events: auto;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            margin-top: 20px;
            border-radius: 4px;
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff;
        }

        .btn:active {
            transform: scale(0.95);
        }

        /* CRT Scanline Effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 100;
            animation: scanlineMove 10s linear infinite;
        }
        
        /* Slight vignette */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 99;
        }

        @keyframes scanlineMove {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        .hidden {
            display: none !important;
        }
        
        /* Glitch text effect for Game Over */
        .glitch {
            position: relative;
            animation: glitch-skew 1s infinite linear alternate-reverse;
        }
        .glitch::before{
            content: attr(data-text);
            position: absolute;
            left: 0;
            text-shadow: -2px 0 #ff00c1;
            overflow: hidden;
            top: 0;
            animation: glitch-anim-1 2s infinite linear alternate-reverse;
        }
        .glitch::after {
            content: attr(data-text);
            position: absolute;
            left: 0;
            text-shadow: -2px 0 #00fff9;
            overflow: hidden;
            top: 0;
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim-1 {
            0% { clip-path: inset(20% 0 80% 0); }
            20% { clip-path: inset(60% 0 10% 0); }
            40% { clip-path: inset(40% 0 50% 0); }
            60% { clip-path: inset(80% 0 5% 0); }
            80% { clip-path: inset(10% 0 60% 0); }
            100% { clip-path: inset(30% 0 30% 0); }
        }
        @keyframes glitch-anim-2 {
            0% { clip-path: inset(10% 0 60% 0); }
            20% { clip-path: inset(80% 0 5% 0); }
            40% { clip-path: inset(30% 0 20% 0); }
            60% { clip-path: inset(10% 0 80% 0); }
            80% { clip-path: inset(50% 0 30% 0); }
            100% { clip-path: inset(70% 0 10% 0); }
        }

    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Visual Effects -->
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <!-- HUD -->
    <div id="hud" class="hud hidden">
        THREADS: <span id="scoreDisplay" class="score-val">0</span><br>
        <span style="font-size: 14px; color: #888;">GAP SIZE: <span id="difficultyDisplay">100%</span></span>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="ui-layer">
        <h1 class="text-6xl mb-4 font-black tracking-widest" style="color:#0ff; text-shadow: 0 0 20px #0ff;">CYBER THREAD</h1>
        <p class="text-xl mb-8 tracking-wider text-gray-300">ÁÑ°Èôê„ÅÆÈõªËÑ≥Á©∫Èñì„ÇíÁ™Å„ÅçÈÄ≤„ÇÅ</p>
        <div class="text-sm mb-8 p-4 border border-cyan-500 bg-black bg-opacity-50 rounded">
            <p class="mb-2">„ÄêÊìç‰ΩúÊñπÊ≥ï„Äë</p>
            <p>üñ±Ô∏è „Éû„Ç¶„Çπ / üëÜ „Çø„ÉÉ„Éó: <span class="text-pink-500 font-bold">‰∏äÊòá</span></p>
            <p>Èõ¢„Åô: <span class="text-cyan-500 font-bold">‰∏ãÈôç</span></p>
        </div>
        <button id="startBtn" class="btn">SYSTEM START</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="ui-layer hidden">
        <h2 class="text-6xl mb-4 font-black glitch" data-text="CRITICAL ERROR" style="color:#f0f;">CRITICAL ERROR</h2>
        <p class="text-2xl mb-2">SYSTEM HALTED</p>
        <p class="text-xl mb-8">PASSED THREADS: <span id="finalScore" class="text-4xl text-yellow-400 font-bold">0</span></p>
        <button id="restartBtn" class="btn">REBOOT SYSTEM</button>
    </div>

<script>
/**
 * CYBER THREAD GAME ENGINE
 * Audio-Visual implementation using HTML5 Canvas
 */

// --- Audio System (Simple Synth) ---
const AudioSys = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playCrash: function() {
        if (!this.ctx) return;
        // White noise burst
        const bufferSize = this.ctx.sampleRate * 0.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
        
        // Low boom
        this.playTone(100, 'sawtooth', 0.5, 0.5);
        this.playTone(50, 'square', 0.8, 0.5);
    },
    playScore: function() {
        this.playTone(800 + Math.random()*200, 'sine', 0.1, 0.05);
    },
    playStart: function() {
        this.playTone(440, 'square', 0.2, 0.1);
        setTimeout(() => this.playTone(880, 'square', 0.4, 0.1), 200);
    }
};

// --- Game Logic ---

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on base canvas

// UI Elements
const startScreen = document.getElementById('startScreen');
const gameOverScreen = document.getElementById('gameOverScreen');
const hud = document.getElementById('hud');
const scoreDisplay = document.getElementById('scoreDisplay');
const difficultyDisplay = document.getElementById('difficultyDisplay');
const finalScoreDisplay = document.getElementById('finalScore');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');

// Game State
let gameState = 'START'; // START, PLAYING, GAMEOVER
let passedCount = 0; // "Threads passed successfully" (SCORE)
let totalEncountered = 0; // Total obstacles encountered (DIFFICULTY)
let frames = 0;
const GAME_SPEED = 3.0; // Base Speed for 60FPS
let animationId = null; 
let lastTime = 0; // For Delta Time
let width, height;

// Physics Constants
const GRAVITY = 0.4; // Downward force
const LIFT = -0.4;   // Upward force when holding
const MAX_VELOCITY = 7; // Cap max velocity

// Player (The Thread Head)
const player = {
    x: 100, // Fixed X position
    y: 0,
    radius: 4,
    velocity: 0,
    trail: [], // Array of {x, y}
    trailLength: 40,
    color: '#0ff'
};

// Obstacles (Needles)
let obstacles = [];
const NEEDLE_BODY_WIDTH = 30; // The bulge width
const NEEDLE_SHAFT_WIDTH = 8; // Narrowed
const OBSTACLE_SPACING = 300; // Distance between walls

// Difficulty Settings
let initialGapSize = 150; // Set to 150px
let minGapSize = 30;      // Set to 30px
let currentGapSize = initialGapSize;

// Particles
let particles = [];

// Input
let isHolding = false;

// Initialization
function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    player.x = width * 0.2; // Player stays at 20% of screen width
}

window.addEventListener('resize', resize);
resize();

// Input Handlers
function handleInputStart(e) {
    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
        return;
    }

    if (e.type === 'touchstart') e.preventDefault(); // Prevent scrolling
    isHolding = true;
}

function handleInputEnd(e) {
    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
        return;
    }
    
    if (e.type === 'touchend') e.preventDefault();
    isHolding = false;
}

window.addEventListener('mousedown', handleInputStart);
window.addEventListener('touchstart', handleInputStart, { passive: false });
window.addEventListener('mouseup', handleInputEnd);
window.addEventListener('touchend', handleInputEnd, { passive: false });

// Game Loop Functions

function resetGame() {
    player.y = height / 2;
    player.velocity = 0;
    player.trail = [];
    isHolding = false; 

    // Pre-fill trail
    for(let i=0; i<player.trailLength; i++) {
        player.trail.push({x: player.x - i*5, y: player.y});
    }
    
    obstacles = [];
    particles = [];
    passedCount = 0;
    totalEncountered = 0;
    currentGapSize = initialGapSize;
    frames = 0;
    lastTime = 0; // Reset time for Delta Time
    
    // Create first obstacle far away
    addObstacle(width + 200);
}

function startGame() {
    AudioSys.init();
    AudioSys.playStart();
    
    if (animationId) {
        cancelAnimationFrame(animationId);
    }
    
    gameState = 'PLAYING';
    startScreen.classList.add('hidden');
    gameOverScreen.classList.add('hidden');
    hud.classList.remove('hidden');
    resetGame();
    // Start loop via requestAnimationFrame to get valid initial timestamp
    animationId = requestAnimationFrame(animate);
}

function gameOver() {
    if (gameState === 'GAMEOVER') return; 
    
    AudioSys.playCrash();
    gameState = 'GAMEOVER';
    finalScoreDisplay.textContent = passedCount;
    hud.classList.add('hidden');
    gameOverScreen.classList.remove('hidden');
    createExplosion(player.x, player.y, 50, '#f0f');
}

function addObstacle(xOffset) {
    const padding = 100;
    const maxGapTop = height - currentGapSize - 50;
    const minGapTop = padding;
    const gapTop = Math.random() * (maxGapTop - minGapTop) + minGapTop;
    
    obstacles.push({
        x: xOffset,
        width: NEEDLE_BODY_WIDTH,
        gapTop: gapTop,
        gapHeight: currentGapSize,
        passed: false,
        tipHeight: 15
    });
}

function createExplosion(x, y, count, color) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 15,
            vy: (Math.random() - 0.5) * 15,
            life: 1.0,
            color: color
        });
    }
}

function update(timeScale) {
    if (gameState !== 'PLAYING') return;

    // --- Difficulty Scaling ---
    // Decrease gap size by 5% of INITIAL size every 10 threads ENCOUNTERED (not just passed successfully)
    const reductionSteps = Math.floor(totalEncountered / 10);
    const reductionAmount = reductionSteps * (initialGapSize * 0.05);
    currentGapSize = Math.max(minGapSize, initialGapSize - reductionAmount);

    // --- Physics with Delta Time ---
    const gravityScaled = GRAVITY * timeScale;
    const liftScaled = LIFT * timeScale;

    if (isHolding) {
        player.velocity += liftScaled;
    } else {
        player.velocity += gravityScaled;
    }

    // Dampening (Approximation for frame independence)
    // 0.96 at 1.0 scale -> loss of 0.04
    player.velocity *= (1 - 0.04 * timeScale);

    // Cap velocity (Absolute limits)
    if (player.velocity > MAX_VELOCITY) player.velocity = MAX_VELOCITY;
    if (player.velocity < -MAX_VELOCITY) player.velocity = -MAX_VELOCITY;

    // Apply Velocity
    player.y += player.velocity * timeScale;

    // Ceiling/Floor collision
    if (player.y < 0 || player.y > height) {
        gameOver();
        return;
    }

    // --- Movement with Delta Time ---
    const moveAmount = GAME_SPEED * timeScale;

    // Trail Logic
    for (let t of player.trail) {
        t.x -= moveAmount;
    }
    player.trail.unshift({x: player.x, y: player.y});
    if (player.trail.length > player.trailLength) {
        player.trail.pop();
    }

    // Obstacle Logic
    if (obstacles.length > 0) {
        const lastObs = obstacles[obstacles.length - 1];
        if (width - lastObs.x > OBSTACLE_SPACING) {
            addObstacle(width);
        }
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
        let obs = obstacles[i];
        obs.x -= moveAmount;

        // Collision Detection
        if (player.x + player.radius > obs.x && player.x - player.radius < obs.x + obs.width) {
            
            const inHole = (player.y - player.radius > obs.gapTop) && 
                           (player.y + player.radius < obs.gapTop + obs.gapHeight);
            
            if (!inHole) {
                const hitBottom = (player.y + player.radius > obs.gapTop + obs.gapHeight);
                const hitTopTip = (player.y - player.radius < obs.gapTop) && 
                                  (player.y + player.radius > obs.gapTop - obs.tipHeight);

                if (hitBottom || hitTopTip) {
                    gameOver();
                    return;
                }
            }
        }

        // Scoring & Difficulty Counting
        if (!obs.passed && player.x > obs.x + obs.width) {
            obs.passed = true;
            totalEncountered++; // Increment difficulty counter regardless of success

            // Score only if passed through the hole
            if (player.y > obs.gapTop && player.y < obs.gapTop + obs.gapHeight) {
                passedCount++;
                createExplosion(obs.x + obs.width, player.y, 5, '#0ff');
                AudioSys.playScore();
            }
        }

        // Remove off-screen obstacles
        if (obs.x + obs.width < -100) {
            obstacles.splice(i, 1);
        }
    }

    // Update Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * timeScale;
        p.y += p.vy * timeScale;
        p.life -= 0.02 * timeScale;
        if (p.life <= 0) particles.splice(i, 1);
    }
    
    // Update HUD
    scoreDisplay.innerText = passedCount;
    // Show current size percentage relative to initial
    let currentPercent = Math.max(0, Math.floor((currentGapSize / initialGapSize) * 100));
    difficultyDisplay.innerText = `HOLE SIZE: ${currentPercent}%`;
}

function draw() {
    // Clear Background
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, width, height);

    // Draw Grid (Perspective Effect)
    drawGrid();

    // Draw Obstacles (Needles)
    ctx.save();
    
    obstacles.forEach(obs => {
        // Metallic Gradient for the needle
        const grad = ctx.createLinearGradient(obs.x, 0, obs.x + obs.width, 0);
        grad.addColorStop(0, '#555');
        grad.addColorStop(0.3, '#bbb');
        grad.addColorStop(0.5, '#fff'); // Shine
        grad.addColorStop(0.7, '#bbb');
        grad.addColorStop(1, '#555');
        
        ctx.fillStyle = grad;
        
        // Needle Geometry Calculation
        const shaftWidth = NEEDLE_SHAFT_WIDTH;
        const shaftX = obs.x + (obs.width - shaftWidth) / 2;
        
        const eyeTopY = obs.gapTop;
        const eyeBottomY = obs.gapTop + obs.gapHeight;
        
        // Start Path
        ctx.beginPath();
        
        // 1. Tip (Point)
        const tipY = obs.gapTop - obs.tipHeight;
        ctx.moveTo(obs.x + obs.width / 2, tipY); // The sharp point
        
        // 2. Curve down to Eye Top (Bulge)
        // Right side curve
        ctx.quadraticCurveTo(obs.x + obs.width, obs.gapTop - 10, obs.x + obs.width, obs.gapTop + 10);
        
        // 3. Right side of Eye/Shaft
        // Go down to bottom of eye bulge
        ctx.lineTo(obs.x + obs.width, eyeBottomY - 10);
        // Curve in to shaft
        ctx.quadraticCurveTo(obs.x + obs.width, eyeBottomY, shaftX + shaftWidth, eyeBottomY + 20);
        
        // 4. Bottom Shaft (Right side)
        ctx.lineTo(shaftX + shaftWidth, height);
        
        // 5. Bottom Shaft (Left side)
        ctx.lineTo(shaftX, height);
        ctx.lineTo(shaftX, eyeBottomY + 20);
        
        // 6. Curve out to Left Eye Bulge
        ctx.quadraticCurveTo(obs.x, eyeBottomY, obs.x, eyeBottomY - 10);
        
        // 7. Left side up to Tip
        ctx.lineTo(obs.x, obs.gapTop + 10);
        ctx.quadraticCurveTo(obs.x, obs.gapTop - 10, obs.x + obs.width / 2, tipY);
        
        ctx.closePath();
        ctx.fill();

        // 8. The Hole (Cutout)
        // Use destination-out to make transparent
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        // Ellipse hole
        const holeWidth = obs.width * 0.6;
        const holeHeight = obs.gapHeight * 0.8;
        const holeX = obs.x + (obs.width - holeWidth) / 2;
        const holeY = obs.gapTop + (obs.gapHeight - holeHeight) / 2;
        
        // Draw capsule shape for hole
        ctx.roundRect(holeX, holeY, holeWidth, holeHeight, holeWidth/2);
        ctx.fill();
        
        // Reset composite
        ctx.globalCompositeOperation = 'source-over';

        // 9. Neon Outline & Glow
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#0ff';
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.8;
        
        // Let's just stroke the outline of the hole for effect
        ctx.beginPath();
        ctx.roundRect(holeX, holeY, holeWidth, holeHeight, holeWidth/2);
        ctx.stroke();
        
        ctx.restore();

    });
    ctx.restore();

    // Draw Thread (Player)
    if (player.trail.length > 1) {
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Glow effect
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#f0f'; // Pinkish/Purple laser
        
        // Draw the tail
        ctx.beginPath();
        ctx.moveTo(player.trail[0].x, player.trail[0].y);
        
        for (let i = 1; i < player.trail.length; i++) {
            ctx.lineTo(player.trail[i].x, player.trail[i].y);
        }
        
        // Gradient stroke
        const gradient = ctx.createLinearGradient(player.trail[player.trail.length-1].x, 0, player.x, 0);
        gradient.addColorStop(0, 'rgba(255, 0, 255, 0)');
        gradient.addColorStop(1, '#f0f');
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Draw Head
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }

    // Draw Particles
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.random() * 3 + 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    });

    // Draw Floor/Ceiling Danger Lines
    ctx.fillStyle = '#f00';
    ctx.fillRect(0, 0, width, 5);
    ctx.fillRect(0, height-5, width, 5);
}

function drawGrid() {
    ctx.save();
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    
    const gridSize = 50;
    // Use frames for simpler grid animation (visual only), or convert to time based if needed.
    // For visual consistency, let's keep using frames but maybe slower
    const xOffset = (frames * GAME_SPEED) % gridSize;

    // Vertical lines
    for (let x = -xOffset; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
    }

    // Horizontal lines
    for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
    }
    
    // Horizon glow
    const gradient = ctx.createLinearGradient(0, height/2 - 100, 0, height/2 + 100);
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(0.5, 'rgba(0, 255, 255, 0.05)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    ctx.restore();
}

function animate(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    // Normalize to 60 FPS (approx 16.67ms per frame)
    // If running at 120fps, deltaTime is ~8.3ms, so scale is 0.5
    // If running at 60fps, deltaTime is ~16.7ms, so scale is 1.0
    // Cap delta time to prevent huge jumps (e.g. switching tabs)
    const safeDelta = Math.min(deltaTime, 100);
    const timeScale = safeDelta / 16.67;

    frames++; // Visual frame counter
    update(timeScale);
    draw();
    
    if (gameState === 'PLAYING' || gameState === 'GAMEOVER') {
        animationId = requestAnimationFrame(animate);
    }
}

// Button Events
startBtn.addEventListener('click', startGame);
restartBtn.addEventListener('click', startGame);

// Initial Draw (Background)
resize();
drawGrid();

</script>
</body>
</html>
