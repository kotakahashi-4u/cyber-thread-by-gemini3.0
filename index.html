<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON HYPER HOCKEY 3D - v7.1 (Mobile Sensitivity Fix)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Segoe UI', sans-serif; user-select: none; touch-action: none; }
        canvas { display: block; }
        
        /* --- UI Layer (HUD Style) --- */
        #ui-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        /* Top HUD Bar */
        .hud-top {
            width: 100%;
            padding: 20px 40px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0) 100%);
        }

        /* Score Display */
        .score-container {
            display: flex;
            gap: 40px;
            align-items: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .score-box {
            font-size: 60px;
            font-weight: 900;
            width: 80px;
            text-align: center;
            position: relative;
        }
        
        .p-score { 
            color: #00ffff; 
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
        }
        .e-score { 
            color: #ff0055; 
            text-shadow: 0 0 20px #ff0055, 0 0 40px #ff0055; 
        }
        
        .score-divider {
            color: #fff;
            font-size: 40px;
            opacity: 0.5;
        }

        /* Modern Pause Button */
        .pause-btn-container {
            pointer-events: auto;
            cursor: pointer;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(5px);
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 20;
        }

        .pause-btn-container:hover {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            background: rgba(0, 255, 255, 0.1);
        }

        .pause-icon {
            width: 18px;
            height: 20px;
            display: flex;
            justify-content: space-between;
        }

        .pause-bar {
            width: 5px;
            height: 100%;
            background-color: #fff;
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(255,255,255,0.8);
        }

        /* Pause Menu Overlay */
        #pause-menu {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(15px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: auto;
        }
        
        .pause-title {
            color: #fff; 
            font-size: 40px; 
            margin-bottom: 50px; 
            letter-spacing: 15px;
            text-shadow: 0 0 10px #fff;
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }

        /* Start / Menu Screen */
        #menu-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 0.5s;
        }
        
        h1 {
            color: #fff;
            font-size: 70px;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 8px;
            background: linear-gradient(90deg, #00ffff, #fff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(0,255,255,0.5));
            animation: float 4s ease-in-out infinite;
            text-align: center;
            padding: 0 20px;
        }

        .subtitle {
            color: #888;
            font-size: 14px;
            letter-spacing: 4px;
            margin-top: 10px;
            margin-bottom: 50px;
            text-transform: uppercase;
            text-align: center;
        }

        .btn-group { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; width: 100%; max-width: 800px; }
        .v-stack { display: flex; flex-direction: column; gap: 25px; align-items: center; min-width: 300px; }
        
        /* Modern Buttons */
        button {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 18px 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }

        button::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }

        button:hover::before { left: 100%; }
        button:hover { transform: translateY(-3px); border-color: #fff; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }

        /* Difficulty Colors */
        button.mode-easy:hover { border-color: #00ff00; box-shadow: 0 0 25px rgba(0,255,0,0.4); color: #00ff00; }
        button.mode-normal:hover { border-color: #00ffff; box-shadow: 0 0 25px rgba(0,255,255,0.4); color: #00ffff; }
        button.mode-hard:hover { border-color: #ffaa00; box-shadow: 0 0 25px rgba(255,170,0,0.4); color: #ffaa00; }
        button.mode-hell { border-color: rgba(255,0,85,0.5); color: #ff0055; font-weight: 800; }
        button.mode-hell:hover { background: #ff0055; color: #fff; box-shadow: 0 0 50px #ff0055; }

        /* Checkbox Style */
        .option-toggle {
            margin-top: 30px;
            display: flex;
            align-items: center;
            color: #aaa;
            cursor: pointer;
            font-size: 14px;
            letter-spacing: 1px;
        }
        .option-toggle input { margin-right: 10px; accent-color: #00ffff; transform: scale(1.2); }

        #message {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-style: italic;
            font-weight: 900;
            color: white;
            display: none;
            z-index: 15;
            text-align: center;
            pointer-events: none;
            -webkit-text-stroke: 2px rgba(0,0,0,0.5);
            text-shadow: 0 0 50px rgba(255,255,255,0.8);
            width: 100%;
        }
        
        @media (max-width: 800px) {
            h1 { font-size: 40px; }
            .subtitle { font-size: 10px; }
            .hud-top { padding: 15px 20px; }
            .score-box { font-size: 50px; width: 60px; }
            .score-divider { font-size: 30px; }
            .pause-btn-container { width: 60px; height: 60px; }
            .pause-icon { width: 22px; height: 24px; }
            button { padding: 20px 30px; font-size: 16px; width: 80%; max-width: 300px; margin-bottom: 10px; }
            .btn-group { flex-direction: column; align-items: center; gap: 10px; }
            #message { font-size: 80px; }
        }
    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- HUD Layer -->
    <div id="ui-layer">
        <div class="hud-top">
            <div style="width: 50px;"></div>
            <div class="score-container">
                <div class="score-box p-score" id="score-player">0</div>
                <div class="score-divider">-</div>
                <div class="score-box e-score" id="score-enemy">0</div>
            </div>
            <div class="pause-btn-container" id="pause-btn" onclick="togglePause()">
                <div class="pause-icon">
                    <div class="pause-bar"></div>
                    <div class="pause-bar"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pause-menu">
        <div class="pause-title">PAUSED</div>
        <div class="v-stack">
            <button onclick="togglePause()">RESUME GAME</button>
            <button onclick="quitGame()">EXIT TO TITLE</button>
        </div>
    </div>

    <!-- Goal Message -->
    <div id="message">GOAL!</div>

    <!-- Title Screen -->
    <div id="menu-screen">
        <h1>Neon Hockey</h1>
        <div class="subtitle">CYBERNETIC SPORTS SIMULATION</div>
        <div style="margin-bottom: 15px; color:#fff; letter-spacing: 2px; font-size:12px;">SELECT DIFFICULTY</div>
        <div class="btn-group">
            <button class="mode-easy" onclick="startGame('easy')">Beginner</button>
            <button class="mode-normal" onclick="startGame('normal')">Normal</button>
            <button class="mode-hard" onclick="startGame('hard')">Expert</button>
            <button class="mode-hell" onclick="startGame('hell')">HELL MODE</button>
        </div>
        <label class="option-toggle">
            <input type="checkbox" id="multi-puck-toggle"> 
            ENABLE CHAOS MODE (2 PUCKS)
        </label>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            tableWidth: 60,
            tableHeight: 100,
            goalWidth: 20,
            puckRadius: 2.5,
            paddleRadius: 3.5,
            wallRestitution: 0.9,
            paddleRestitution: 1.1,
            friction: 0.990,
            winScore: 7,
            cornerCut: 8 // Size of the corner cut to prevent sticking
        };

        const AI_LEVELS = {
            'easy':   { speed: 0.04, error: 2.5, reaction: 0.8 },
            'normal': { speed: 0.09, error: 1.0, reaction: 0.5 },
            'hard':   { speed: 0.18, error: 0.2, reaction: 0.2 },
            'hell':   { speed: 0.40, error: 0.0, reaction: 0.0 }
        };

        let state = {
            isPlaying: false,
            isPaused: false,
            scoreP: 0,
            scoreE: 0,
            difficulty: 'normal',
            pucks: [],
            cameraShake: 0,
            baseCameraPos: new THREE.Vector3(0, 100, 100),
            isMobile: false
        };

        // --- Audio ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (!state.isPlaying || state.isPaused) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'hit') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(220, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
                gain.gain.setValueAtTime(0.4, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'wall') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.05);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            } else if (type === 'goal') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 1.2);
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 1.2);
                osc.start(now);
                osc.stop(now + 1.2);
            }
        }

        // --- Three.js Init ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // Bloom Effect
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15;
        bloomPass.strength = 1.6;
        bloomPass.radius = 0.4;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Scene Construction ---
        const ambientLight = new THREE.AmbientLight(0x444444);
        scene.add(ambientLight);

        // Grid Floor
        const gridHelper = new THREE.GridHelper(400, 100, 0x555555, 0x1a1a1a);
        gridHelper.position.y = -2;
        scene.add(gridHelper);

        const tableGroup = new THREE.Group();
        scene.add(tableGroup);

        // Table Surface
        const floorGeo = new THREE.PlaneGeometry(CONFIG.tableWidth + 4, CONFIG.tableHeight + 4);
        const floorMat = new THREE.MeshStandardMaterial({ 
            color: 0x0a0a0a, 
            roughness: 0.1, 
            metalness: 0.5 
        });
        const floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = -0.1;
        tableGroup.add(floorMesh);

        // Neon Materials
        const neonMatBlue = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2.0 });
        const neonMatRed = new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0xff0055, emissiveIntensity: 2.0 });
        const neonMatYellow = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.5 });
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2, metalness: 0.8 });

        function createWall(w, h, d, x, z, mat, isNeon = false) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, isNeon ? mat : wallMat);
            mesh.position.set(x, h/2, z);
            
            if (!isNeon) {
                const stripGeo = new THREE.BoxGeometry(w, 0.2, d);
                const strip = new THREE.Mesh(stripGeo, mat);
                strip.position.y = h/2 + 0.1;
                mesh.add(strip);
            }
            
            tableGroup.add(mesh);
            return mesh;
        }

        // --- CORNER WALLS (Prevent Stuck) ---
        function createCornerWalls() {
            const size = CONFIG.cornerCut * 1.5; // Visual size length
            const dist = (CONFIG.tableWidth/2 + CONFIG.tableHeight/2) - CONFIG.cornerCut; 
            
            const thickness = 2;
            const geo = new THREE.BoxGeometry(size, 2, thickness);
            
            // 4 Corners
            const corners = [
                { x: -CONFIG.tableWidth/2, z: -CONFIG.tableHeight/2, rot: Math.PI/4, mat: neonMatBlue }, // Top-Left
                { x: CONFIG.tableWidth/2, z: -CONFIG.tableHeight/2, rot: -Math.PI/4, mat: neonMatBlue }, // Top-Right
                { x: -CONFIG.tableWidth/2, z: CONFIG.tableHeight/2, rot: -Math.PI/4, mat: neonMatBlue }, // Bot-Left
                { x: CONFIG.tableWidth/2, z: CONFIG.tableHeight/2, rot: Math.PI/4, mat: neonMatBlue }  // Bot-Right
            ];

            corners.forEach(c => {
                // Offset calculation to place the 45deg wall correctly
                // We want to cut the corner by CONFIG.cornerCut
                // Shift inwards
                const offsetX = (c.x > 0 ? -1 : 1) * (CONFIG.cornerCut/2);
                const offsetZ = (c.z > 0 ? -1 : 1) * (CONFIG.cornerCut/2);
                
                const mesh = new THREE.Mesh(geo, c.mat);
                mesh.rotation.y = c.rot;
                // Simple positioning approx
                mesh.position.set(c.x + offsetX, 1, c.z + offsetZ);
                tableGroup.add(mesh);
            });
        }
        createCornerWalls();

        // Side Walls
        createWall(2, 3, CONFIG.tableHeight - CONFIG.cornerCut*2, -CONFIG.tableWidth/2 - 1, 0, neonMatBlue); 
        createWall(2, 3, CONFIG.tableHeight - CONFIG.cornerCut*2, CONFIG.tableWidth/2 + 1, 0, neonMatBlue); 

        // End Walls (adjusted for corners)
        const wallW = (CONFIG.tableWidth - CONFIG.goalWidth) / 2 - CONFIG.cornerCut;
        // Top (Enemy)
        createWall(wallW, 3, 2, -wallW/2 - CONFIG.goalWidth/2, -CONFIG.tableHeight/2 - 1, neonMatRed);
        createWall(wallW, 3, 2, wallW/2 + CONFIG.goalWidth/2, -CONFIG.tableHeight/2 - 1, neonMatRed);
        // Bottom (Player)
        createWall(wallW, 3, 2, -wallW/2 - CONFIG.goalWidth/2, CONFIG.tableHeight/2 + 1, neonMatBlue);
        createWall(wallW, 3, 2, wallW/2 + CONFIG.goalWidth/2, CONFIG.tableHeight/2 + 1, neonMatBlue);

        // Center Line
        const centerLine = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.tableWidth, 0.5), neonMatBlue);
        centerLine.rotation.x = -Math.PI / 2;
        centerLine.position.y = 0.01;
        tableGroup.add(centerLine);

        // Center Circle
        const circleGeo = new THREE.RingGeometry(9, 10, 64);
        const circleMesh = new THREE.Mesh(circleGeo, neonMatBlue);
        circleMesh.rotation.x = -Math.PI / 2;
        circleMesh.position.y = 0.01;
        tableGroup.add(circleMesh);

        // Game Entities
        function createPaddle(color) {
            const group = new THREE.Group();
            const geo = new THREE.CylinderGeometry(CONFIG.paddleRadius, CONFIG.paddleRadius, 1.5, 32);
            const mat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2, metalness: 0.8 });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Neon Ring
            const ringGeo = new THREE.TorusGeometry(CONFIG.paddleRadius, 0.3, 16, 32);
            const ringMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 2.0 });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.5;
            
            const light = new THREE.PointLight(color, 80, 25);
            light.position.y = 2;
            
            group.add(mesh);
            group.add(ring);
            group.add(light);
            scene.add(group);
            
            return { mesh: group, velocity: new THREE.Vector3(), targetPos: new THREE.Vector3() };
        }

        const playerPaddle = createPaddle(0x00ffff);
        const enemyPaddle = createPaddle(0xff0055);

        class Puck {
            constructor() {
                const geo = new THREE.CylinderGeometry(CONFIG.puckRadius, CONFIG.puckRadius, 1, 32);
                this.mesh = new THREE.Mesh(geo, neonMatYellow);
                const light = new THREE.PointLight(0xffff00, 50, 15);
                light.position.y = 1;
                this.mesh.add(light);
                scene.add(this.mesh);
                this.velocity = new THREE.Vector3(0, 0, 0);
                this.reset();
            }
            reset() {
                this.mesh.position.set(0, 0.5, 0);
                const dir = Math.random() > 0.5 ? 1 : -1;
                this.velocity.set((Math.random() - 0.5) * 1, 0, dir * 1);
            }
            remove() {
                scene.remove(this.mesh);
            }
        }

        // Particles
        const particles = [];
        function spawnParticles(pos, color) {
            const geom = new THREE.BufferGeometry();
            const count = 40;
            const positions = new Float32Array(count * 3);
            const velocities = [];
            for(let i=0; i<count; i++) {
                positions[i*3] = pos.x;
                positions[i*3+1] = pos.y;
                positions[i*3+2] = pos.z;
                velocities.push({
                    x: (Math.random() - 0.5) * 3,
                    y: (Math.random()) * 3,
                    z: (Math.random() - 0.5) * 3
                });
            }
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({
                color: color, size: 0.5, transparent: true, opacity: 1, blending: THREE.AdditiveBlending
            });
            const sys = new THREE.Points(geom, mat);
            scene.add(sys);
            particles.push({ mesh: sys, vels: velocities, life: 1.0 });
        }

        function updateParticles() {
            if (state.isPaused) return;
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.04;
                const positions = p.mesh.geometry.attributes.position.array;
                for(let j=0; j<p.vels.length; j++) {
                    positions[j*3] += p.vels[j].x;
                    positions[j*3+1] += p.vels[j].y;
                    positions[j*3+2] += p.vels[j].z;
                }
                p.mesh.geometry.attributes.position.needsUpdate = true;
                p.mesh.material.opacity = p.life;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        // --- Input ---
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

        function updateMouse(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
        }

        window.addEventListener('mousemove', e => updateMouse(e.clientX, e.clientY));
        window.addEventListener('touchmove', e => {
            e.preventDefault(); // Prevent scrolling/zooming default actions
            if(e.touches.length > 0) updateMouse(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        // --- Logic ---
        function checkCornerCollision(puck) {
            // Corner Cut Collision Logic (45 deg walls)
            const x = puck.mesh.position.x;
            const z = puck.mesh.position.z;
            const r = CONFIG.puckRadius;
            const cut = CONFIG.cornerCut;
            const W2 = CONFIG.tableWidth / 2;
            const H2 = CONFIG.tableHeight / 2;
            
            // Normal vectors for 4 corners (normalized)
            const nInvSqrt2 = 0.7071; // 1/sqrt(2)

            // 1. Bottom-Right (+x, +z)
            // Line: x + z = (W2 + H2) - cut*sqrt(2) ? No, simpler approx:
            // Check distance to the diagonal line connecting (W2-cut, H2) and (W2, H2-cut)
            // Equation: x + z > Limit
            // Limit approx: W2 + H2 - cut
            if (x > 0 && z > 0) {
                if (x + z > (W2 + H2 - cut) - r) {
                    // Reflect velocity against (-1, -1)
                    const dot = puck.velocity.x * -nInvSqrt2 + puck.velocity.z * -nInvSqrt2;
                    puck.velocity.x -= 2 * dot * -nInvSqrt2;
                    puck.velocity.z -= 2 * dot * -nInvSqrt2;
                    // Push out
                    const overlap = (x + z) - ((W2 + H2 - cut) - r);
                    puck.mesh.position.x -= overlap * nInvSqrt2;
                    puck.mesh.position.z -= overlap * nInvSqrt2;
                    playSound('wall');
                }
            }
            // 2. Bottom-Left (-x, +z)
            else if (x < 0 && z > 0) {
                 if (-x + z > (W2 + H2 - cut) - r) {
                    const dot = puck.velocity.x * nInvSqrt2 + puck.velocity.z * -nInvSqrt2;
                    puck.velocity.x -= 2 * dot * nInvSqrt2;
                    puck.velocity.z -= 2 * dot * -nInvSqrt2;
                    const overlap = (-x + z) - ((W2 + H2 - cut) - r);
                    puck.mesh.position.x += overlap * nInvSqrt2;
                    puck.mesh.position.z -= overlap * nInvSqrt2;
                    playSound('wall');
                 }
            }
            // 3. Top-Right (+x, -z)
            else if (x > 0 && z < 0) {
                 if (x - z > (W2 + H2 - cut) - r) {
                    const dot = puck.velocity.x * -nInvSqrt2 + puck.velocity.z * nInvSqrt2;
                    puck.velocity.x -= 2 * dot * -nInvSqrt2;
                    puck.velocity.z -= 2 * dot * nInvSqrt2;
                    const overlap = (x - z) - ((W2 + H2 - cut) - r);
                    puck.mesh.position.x -= overlap * nInvSqrt2;
                    puck.mesh.position.z += overlap * nInvSqrt2;
                    playSound('wall');
                 }
            }
            // 4. Top-Left (-x, -z)
            else if (x < 0 && z < 0) {
                 if (-x - z > (W2 + H2 - cut) - r) {
                    const dot = puck.velocity.x * nInvSqrt2 + puck.velocity.z * nInvSqrt2;
                    puck.velocity.x -= 2 * dot * nInvSqrt2;
                    puck.velocity.z -= 2 * dot * nInvSqrt2;
                    const overlap = (-x - z) - ((W2 + H2 - cut) - r);
                    puck.mesh.position.x += overlap * nInvSqrt2;
                    puck.mesh.position.z += overlap * nInvSqrt2;
                    playSound('wall');
                 }
            }
        }

        function physicsUpdate() {
            if (!state.isPlaying || state.isPaused) return;

            // Player Paddle
            raycaster.setFromCamera(mouse, camera);
            const intersect = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersect);
            
            const limitX = (CONFIG.tableWidth/2) - CONFIG.paddleRadius;
            const limitZ_Top = 5; 
            const limitZ_Bot = (CONFIG.tableHeight/2) - CONFIG.paddleRadius;

            intersect.x = Math.max(-limitX, Math.min(limitX, intersect.x));
            intersect.z = Math.max(limitZ_Top, Math.min(limitZ_Bot, intersect.z));

            const prevPos = playerPaddle.mesh.position.clone();
            
            // Smoothing factor: Lower for mobile to prevent jitter
            const smoothing = state.isMobile ? 0.15 : 0.25;
            playerPaddle.mesh.position.lerp(intersect, smoothing);
            
            // Calculate velocity but Clamp it to prevent physics explosions
            const currentVel = new THREE.Vector3().copy(playerPaddle.mesh.position).sub(prevPos);
            
            // Limit paddle velocity impact
            const maxPaddleVel = 2.0; 
            if (currentVel.length() > maxPaddleVel) {
                currentVel.normalize().multiplyScalar(maxPaddleVel);
            }
            playerPaddle.velocity.copy(currentVel);

            // AI Paddle
            const ai = AI_LEVELS[state.difficulty];
            let targetPuck = null;
            let maxZ = -Infinity;
            state.pucks.forEach(p => {
                if (p.mesh.position.z > maxZ && p.mesh.position.z < 0) {
                    maxZ = p.mesh.position.z;
                    targetPuck = p;
                }
            });

            let targetPos = new THREE.Vector3(0, 0, -40); 
            if (targetPuck) {
                let err = (Math.random()-0.5) * ai.error;
                if(state.difficulty === 'hell') err = 0;
                targetPos.set(targetPuck.mesh.position.x + err, 0, targetPuck.mesh.position.z);
            }
            targetPos.x = Math.max(-limitX, Math.min(limitX, targetPos.x));
            targetPos.z = Math.max(-(CONFIG.tableHeight/2) + CONFIG.paddleRadius, Math.min(-15, targetPos.z)); 

            const aiPrev = enemyPaddle.mesh.position.clone();
            enemyPaddle.mesh.position.lerp(targetPos, ai.speed);
            enemyPaddle.velocity.copy(enemyPaddle.mesh.position).sub(aiPrev);

            // Pucks
            state.pucks.forEach(puck => {
                puck.velocity.multiplyScalar(CONFIG.friction);
                // checkStuck(puck); // Removed old anti-stuck
                checkCornerCollision(puck); // Added physical corner check

                puck.mesh.position.add(puck.velocity);

                const pRad = CONFIG.puckRadius;
                const halfW = CONFIG.tableWidth/2;
                const halfH = CONFIG.tableHeight/2;

                // Side Walls
                if (puck.mesh.position.x > halfW - pRad) {
                    puck.mesh.position.x = halfW - pRad;
                    puck.velocity.x *= -CONFIG.wallRestitution;
                    playSound('wall');
                    spawnParticles(puck.mesh.position, 0x0088ff);
                }
                else if (puck.mesh.position.x < -halfW + pRad) {
                    puck.mesh.position.x = -halfW + pRad;
                    puck.velocity.x *= -CONFIG.wallRestitution;
                    playSound('wall');
                    spawnParticles(puck.mesh.position, 0x0088ff);
                }

                const goalLimit = CONFIG.goalWidth / 2;
                
                // End Walls
                if (puck.mesh.position.z > halfH - pRad) {
                    if (Math.abs(puck.mesh.position.x) < goalLimit) {
                        handleGoal('cpu', puck);
                        return;
                    } else {
                        puck.mesh.position.z = halfH - pRad;
                        puck.velocity.z *= -CONFIG.wallRestitution;
                        playSound('wall');
                    }
                }
                else if (puck.mesh.position.z < -halfH + pRad) {
                    if (Math.abs(puck.mesh.position.x) < goalLimit) {
                        handleGoal('player', puck);
                        return;
                    } else {
                        puck.mesh.position.z = -halfH + pRad;
                        puck.velocity.z *= -CONFIG.wallRestitution;
                        playSound('wall');
                    }
                }

                resolvePaddleCollision(playerPaddle, puck);
                resolvePaddleCollision(enemyPaddle, puck);
            });
        }

        function resolvePaddleCollision(paddle, puck) {
            const dist = paddle.mesh.position.distanceTo(puck.mesh.position);
            const minDist = CONFIG.paddleRadius + CONFIG.puckRadius;

            if (dist < minDist) {
                const angle = Math.atan2(puck.mesh.position.z - paddle.mesh.position.z, puck.mesh.position.x - paddle.mesh.position.x);
                const overlap = minDist - dist;

                puck.mesh.position.x += Math.cos(angle) * overlap;
                puck.mesh.position.z += Math.sin(angle) * overlap;

                const nx = Math.cos(angle);
                const nz = Math.sin(angle);
                
                const impactX = paddle.velocity.x * 2.5; 
                const impactZ = paddle.velocity.z * 2.5;

                const vDotN = puck.velocity.x * nx + puck.velocity.z * nz;
                
                puck.velocity.x = (puck.velocity.x - 2 * vDotN * nx) * 0.8 + impactX;
                puck.velocity.z = (puck.velocity.z - 2 * vDotN * nz) * 0.8 + impactZ;
                
                puck.velocity.multiplyScalar(CONFIG.paddleRestitution);
                
                const speed = puck.velocity.length();
                // Speed Clamping (Min/Max)
                // Mobile speed adjustment (30% slower: 3.5 * 0.7 = 2.45 -> approx 2.5)
                const maxSpeed = state.isMobile ? 2.5 : 3.5;
                if (speed > maxSpeed) puck.velocity.multiplyScalar(maxSpeed / speed);
                
                playSound('hit');
                spawnParticles(puck.mesh.position, 0xffff00);
            }
        }

        function handleGoal(scorer, puck) {
            playSound('goal');
            state.cameraShake = 25;
            spawnParticles(puck.mesh.position, scorer === 'player' ? 0x00ffff : 0xff0055);
            
            if (scorer === 'player') {
                state.scoreP++;
                showMessage("GOAL!");
            } else {
                state.scoreE++;
                showMessage("SCORED!");
            }
            updateScoreUI();

            puck.reset();
            puck.velocity.set(0,0,0);
            
            if (state.scoreP >= CONFIG.winScore || state.scoreE >= CONFIG.winScore) {
                endGame(scorer === 'player');
            } else {
                setTimeout(() => {
                    if (state.isPlaying) {
                        const dir = scorer === 'player' ? -1 : 1; 
                        puck.velocity.set((Math.random()-0.5), 0, dir * 1.0);
                    }
                }, 1000);
            }
        }

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.innerText = text;
            msg.style.display = 'block';
            msg.style.opacity = 1;
            msg.style.transform = "translate(-50%, -50%) scale(1.5)";
            
            let op = 1;
            let scale = 1.5;
            const timer = setInterval(() => {
                if(state.isPaused) return;
                op -= 0.04;
                scale -= 0.02;
                msg.style.opacity = op;
                msg.style.transform = `translate(-50%, -50%) scale(${scale})`;
                
                if (op <= 0) {
                    clearInterval(timer);
                    msg.style.display = 'none';
                }
            }, 50);
        }

        function updateScoreUI() {
            document.getElementById('score-player').innerText = state.scoreP;
            document.getElementById('score-enemy').innerText = state.scoreE;
        }

        function endGame(playerWon) {
            state.isPlaying = false;
            state.isPaused = false;
            const menu = document.getElementById('menu-screen');
            menu.style.display = 'flex';
            document.querySelector('#menu-screen h1').innerText = playerWon ? "VICTORY" : "GAME OVER";
            document.querySelector('#menu-screen h1').style.color = playerWon ? "#00ffff" : "#ff0055";
            document.querySelector('#menu-screen .subtitle').innerText = playerWon ? "SYSTEM DOMINATED" : "TRY AGAIN";
            
            document.getElementById('pause-btn').style.opacity = '0';
        }

        window.startGame = (difficulty) => {
            state.difficulty = difficulty;
            state.scoreP = 0;
            state.scoreE = 0;
            state.isPlaying = true;
            state.isPaused = false;
            updateScoreUI();
            
            state.pucks.forEach(p => p.remove());
            state.pucks = [];
            state.pucks.push(new Puck());
            
            if (document.getElementById('multi-puck-toggle').checked) {
                setTimeout(() => state.pucks.push(new Puck()), 1500);
            }

            if (audioCtx.state === 'suspended') audioCtx.resume();

            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('pause-btn').style.opacity = '1';
            
            state.pucks[0].velocity.set(0, 0, 1);
        };

        window.togglePause = () => {
            if (!state.isPlaying) return;
            state.isPaused = !state.isPaused;
            const menu = document.getElementById('pause-menu');
            
            if (state.isPaused) {
                menu.style.display = 'flex';
            } else {
                menu.style.display = 'none';
            }
        };

        window.quitGame = () => {
            state.isPaused = false;
            state.isPlaying = false;
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('menu-screen').style.display = 'flex';
            document.getElementById('pause-btn').style.opacity = '0';
            
            document.querySelector('#menu-screen h1').innerText = "Neon Hockey";
            document.querySelector('#menu-screen h1').style.background = "linear-gradient(90deg, #00ffff, #fff, #ff00ff)";
            document.querySelector('#menu-screen h1').style.webkitBackgroundClip = "text";
            document.querySelector('#menu-screen h1').style.webkitTextFillColor = "transparent";
            document.querySelector('#menu-screen .subtitle').innerText = "CYBERNETIC SPORTS SIMULATION";
        };

        // --- Camera & Responsive Logic ---
        
        function adjustCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);

            // Updated Camera Logic: Zoom in more to use full screen height
            if (aspect < 1.0) {
                // Portrait (Mobile) - Closer zoom, but high enough to see paddles
                state.baseCameraPos.set(0, 180, 80); 
                state.isMobile = true;
            } else {
                // Landscape (Desktop) - Zoomed in closer to use vertical space
                state.baseCameraPos.set(0, 120, 85); 
                state.isMobile = false;
            }
            camera.position.copy(state.baseCameraPos);
            camera.lookAt(0, 0, 0);
        }

        window.addEventListener('resize', adjustCamera);
        
        // Initial Adjustment
        adjustCamera();

        // --- Render Loop ---
        function animate() {
            requestAnimationFrame(animate);

            physicsUpdate();
            updateParticles();

            // Camera Shake logic
            if (state.cameraShake > 0 && !state.isPaused) {
                const shakeX = (Math.random() - 0.5) * state.cameraShake * 0.1;
                const shakeY = (Math.random() - 0.5) * state.cameraShake * 0.1;
                
                camera.position.x = state.baseCameraPos.x + shakeX;
                camera.position.y = state.baseCameraPos.y + shakeY;
                camera.position.z = state.baseCameraPos.z + shakeY;
                
                camera.lookAt(0,0,0);
                
                state.cameraShake *= 0.9;
                if(state.cameraShake < 0.5) {
                    state.cameraShake = 0;
                    camera.position.copy(state.baseCameraPos);
                    camera.lookAt(0,0,0);
                }
            }

            composer.render();
        }

        document.getElementById('pause-btn').style.opacity = '0'; // Hide until start
        animate();

    </script>
</body>
</html>
